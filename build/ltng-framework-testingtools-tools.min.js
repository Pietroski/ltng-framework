(function(){
function generateUUIDv7() {
const timestamp = Date.now()
const value = new Uint8Array(16)
crypto.getRandomValues(value)
value[0] = (timestamp >> 40) & 0xff
value[1] = (timestamp >> 32) & 0xff
value[2] = (timestamp >> 24) & 0xff
value[3] = (timestamp >> 16) & 0xff
value[4] = (timestamp >> 8) & 0xff
value[5] = timestamp & 0xff
value[6] = (value[6] & 0x0f) | 0x70
value[8] = (value[8] & 0x3f) | 0x80
return [...value].map((b, i) => {
const hex = b.toString(16).padStart(2, '0')
return (i === 4 || i === 6 || i === 8 || i === 10) ? `-${hex}` : hex
}).join('')
}
window.generateUUIDv7 = generateUUIDv7
window.loadCSS = (href) => {
if (!document.querySelector(`link[href="${href}"]`)) {
const link = document.createElement('link')
link.rel = 'stylesheet'
link.href = href
document.head.appendChild(link)
}
}
Object.defineProperty(window, 'Body', {
get: () => document.body
})
window.TextNode = (text) => document.createTextNode(text)
let isHydrated = false
HTMLBodyElement.prototype.render = function (...children) {
if (!isHydrated) {
while (this.firstChild) {
this.removeChild(this.firstChild)
}
isHydrated = true
}
render(this, ...children)
}
HTMLElement.prototype.render = function (...children) {
render(this, ...children)
}
HTMLUnknownElement.prototype.render = function (...children) {
render(this, ...children)
}
function render(parent, ...children) {
children.forEach(child => {
if (typeof child === 'string' || typeof child === 'number') {
parent.appendChild(TextNode(child))
} else if (child instanceof Node) {
parent.appendChild(child)
} else if (Array.isArray(child)) {
child.forEach(c => render(parent, c)) // child.forEach(appendChild) old and wrong
} else if (child === null || child === undefined) {
} else {
parent.appendChild(TextNode(String(child)))
}
})
}
function createElement(tag, props, ...children) {
const element = document.createElement(tag)
if (props) {
for (const [key, value] of Object.entries(props)) {
if (key.startsWith('on') && typeof value === 'function') {
const eventName = key.substring(2).toLowerCase()
element.addEventListener(eventName, value)
} else {
element.setAttribute(key, value)
}
}
} else {
element.setAttribute('class', tag.toLowerCase())
element.setAttribute('id', generateUUIDv7())
}
element.render(children)
return element
}
const tags = [
'div', 'span', 'header', 'footer', 'main', 'section', 'article',
'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'a', 'button', 'input',
'label', 'ul', 'ol', 'li', 'img', 'form', 'nav'
]
tags.forEach(tagName => {
window[tagName] = (props, ...children) => {
return createElement(tagName, props, ...children)
}
})
window.overlayModal = (props, content) => {
const overlay = div({
...props,
style: 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center; z-index: 1000;'
},
div({
style: 'background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); min-width: 300px; display: flex; flex-direction: column; gap: 15px;'
},
div({ style: 'font-size: 1.1em; color: #333;' }, content),
div({ style: 'display: flex; justify-content: flex-end;' },
button({
onClick: (e) => {
const overlayEl = e.target.closest('[style*="position: fixed"]')
if (overlayEl) overlayEl.remove()
},
style: 'padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;'
}, 'Close')
)
)
)
Body.render(overlay)
}
window.createStore = (initialState, options = {}) => {
let state = initialState
const listeners = new Set()
const persistKey = options.persist
if (persistKey) {
const saved = localStorage.getItem(persistKey)
if (saved) {
try {
state = { ...state, ...JSON.parse(saved) }
} catch (e) {
console.error('Failed to parse saved state', e)
}
}
}
const getState = () => state
const setState = (partialState) => {
state = { ...state, ...partialState }
if (persistKey) {
localStorage.setItem(persistKey, JSON.stringify(state))
}
listeners.forEach(listener => listener(state))
}
const subscribe = (listener) => {
listeners.add(listener)
listener(state)
return () => listeners.delete(listener)
}
return { getState, setState, subscribe }
}
})();
(function(){
const colors = {
reset: "\x1b[0m",
red: "\x1b[31m",
green: "\x1b[32m",
yellow: "\x1b[33m",
blue: "\x1b[34m",
magenta: "\x1b[35m",
cyan: "\x1b[36m",
white: "\x1b[37m",
gray: "\x1b[90m",
}
function color(text, colorName) {
return `${colors[colorName] || ""}${text}${colors.reset}`
}
window.colors = colors;
window.color = color;
})();
(function(){
var color = window.color;
const stepDefinitions = []
const features = []
function Given(pattern, fn) {
stepDefinitions.push({ pattern, fn, type: "Given" })
}
function When(pattern, fn) {
stepDefinitions.push({ pattern, fn, type: "When" })
}
function Then(pattern, fn) {
stepDefinitions.push({ pattern, fn, type: "Then" })
}
function Feature(name, fn) {
const feature = { name, scenarios: [] }
features.push(feature)
const currentFeature = feature
global.Scenario = (name, body) => {
currentFeature.scenarios.push({ name, body })
}
fn()
}
async function run() {
console.log(color("\n=== Running Gherkin-like Tests ===\n", "magenta"))
const args = process.argv.slice(2)
let filterRegex = null
const runIndex = args.indexOf("--run")
if (runIndex !== -1 && args[runIndex + 1]) {
try {
filterRegex = new RegExp(args[runIndex + 1])
} catch (e) {
console.error(color(`Invalid filter regex: ${e.message}`, "red"))
process.exit(1)
}
}
let passed = 0
let failed = 0
for (const feature of features) {
const matchingScenarios = feature.scenarios.filter(s =>
!filterRegex || filterRegex.test(s.name) || filterRegex.test(feature.name)
)
if (matchingScenarios.length === 0) continue
console.log(color(`Feature: ${feature.name}`, "blue"))
for (const scenario of matchingScenarios) {
console.log(color(`  Scenario: ${scenario.name}`, "cyan"))
let scenarioFailed = false
const lines = scenario.body
.split("\n")
.map((l) => l.trim())
.filter((l) => l.length > 0)
const context = {} // Shared context for steps in a scenario
for (const line of lines) {
let matchFound = false
const cleanLine = line.replace(/^(Given|When|Then|And|But)\s+/i, "")
for (const stepDef of stepDefinitions) {
let match
if (typeof stepDef.pattern === "string") {
if (cleanLine === stepDef.pattern) {
match = []
} else if (cleanLine.startsWith(stepDef.pattern)) {
}
} else if (stepDef.pattern instanceof RegExp) {
match = cleanLine.match(stepDef.pattern)
}
if (match) {
matchFound = true
try {
const args = match.slice(1)
await stepDef.fn(context, ...args)
console.log(color(`    ${color("✔", "green")} ${line}`, "gray"))
} catch (e) {
console.error(
color(`    ${color("✘", "red")} ${line} \n      Error: ${e.message}`, "red")
)
scenarioFailed = true
}
break // Stop looking for definitions for this line
}
}
if (!matchFound) {
console.error(color(`    ? Undefined step: ${line}`, "yellow"))
scenarioFailed = true
}
if (scenarioFailed) break
}
if (scenarioFailed) {
failed++
} else {
passed++
}
}
}
console.log(color("\n=== Summary ===", "magenta"))
console.log(`Total Scenarios: ${passed + failed}`)
console.log(color(`Passed:          ${passed}`, "green"))
console.log(color(`Failed:          ${failed}`, failed > 0 ? "red" : "green"))
if (failed > 0) {
process.exitCode = 1
}
}
window.Feature = Feature;
window.Given = Given;
window.When = When;
window.Then = Then;
window.run = run;
var __ltng_default_export = {
Feature,
Given,
When,
Then,
run,
}
Object.assign(window, __ltng_default_export);
})();
(function(){
var color = window.color;
const tests = []
let currentSuite = ""
async function Group(name, fn) {
const previousSuite = currentSuite
currentSuite = `${previousSuite}[${name}] `
await fn()
currentSuite = previousSuite
}
function Test(name, fn) {
const testName = `${currentSuite}${name}`
tests.push({ name: testName, fn })
}
async function run() {
let passed = 0
let failed = 0
let skipped = 0
const args = process.argv.slice(2)
let filterRegex = null
const runIndex = args.indexOf("--run")
if (runIndex !== -1 && args[runIndex + 1]) {
try {
filterRegex = new RegExp(args[runIndex + 1])
} catch (e) {
console.error(color(`Invalid filter regex: ${e.message}`, "red"))
process.exit(1)
}
}
console.log(color("\n=== Running Go-like Tests ===\n", "cyan"))
for (const test of tests) {
if (filterRegex && !filterRegex.test(test.name)) {
console.log(color(`    [SKIP] ${test.name}: Filtered out`, "yellow"))
skipped++
continue
}
let isFailed = false
let isSkipped = false
const t = {
name: test.name,
Assert: (condition, msg) => {
if (!condition) {
console.error(
color(`    [FAIL] ${test.name}: ${msg || "Assertion failed"}`, "red")
)
isFailed = true
}
},
Equal: (actual, expected, msg) => {
if (actual !== expected) {
console.error(
color(
`    [FAIL] ${test.name}: ${msg || "Equality check failed"}\n      Expected: ${expected}\n      Actual:   ${actual}`,
"red"
)
)
isFailed = true
}
},
Fail: () => {
isFailed = true
},
Skip: (msg) => {
console.log(color(`    [SKIP] ${test.name}: ${msg || ""}`, "yellow"))
isSkipped = true
},
Log: (...args) => {
console.log(`    [LOG]`, ...args)
},
}
try {
await test.fn(t)
} catch (e) {
console.error(color(`    [ERROR] ${test.name}: ${e.message}`, "red"))
isFailed = true
}
if (isSkipped) {
skipped++
} else if (isFailed) {
failed++
console.log(color(`FAIL: ${test.name}`, "red"))
} else {
passed++
console.log(color(`PASS: ${test.name}`, "green"))
}
}
console.log(color("\n=== Summary ===", "cyan"))
console.log(`Total:   ${tests.length}`)
console.log(color(`Passed:  ${passed}`, "green"))
console.log(color(`Failed:  ${failed}`, failed > 0 ? "red" : "green"))
console.log(color(`Skipped: ${skipped}`, skipped > 0 ? "yellow" : "gray"))
if (failed > 0) {
process.exitCode = 1
}
}
window.Test = Test;
window.Group = Group;
window.run = run;
var __ltng_default_export = {
Test,
Group,
run,
}
Object.assign(window, __ltng_default_export);
})();
(function(){
})();
(function(){
})();
(function(){
var lowerCamelCaseToLowerCaseLowerKebabCase = window.lowerCamelCaseToLowerCaseLowerKebabCase;
const objStrDasher = (obj) =>
Object.entries(obj || {}).reduce(
(previousValue, [key, value]) => ({
...previousValue,
[lowerCamelCaseToLowerCaseLowerKebabCase(key)]: value,
}), {},
)
window.objStrDasher = objStrDasher;
})();
(function(){
const lowerCamelCaseToLowerCaseLowerKebabCase = (camel) =>
camel.replace(/[A-Z]/g, (m) => '-' + m.toLowerCase())
const kebabToLowerSnakeCase = (kebab) =>
kebab.replaceAll('-', '_').toLowerCase()
const lowerCamelCaseToLowerCaseLowerSnakeCase = (camel) =>
camel.replace(/[A-Z]/g, (m) => '_' + m.toLowerCase())
window.lowerCamelCaseToLowerCaseLowerKebabCase = lowerCamelCaseToLowerCaseLowerKebabCase;
window.kebabToLowerSnakeCase = kebabToLowerSnakeCase;
window.lowerCamelCaseToLowerCaseLowerSnakeCase = lowerCamelCaseToLowerCaseLowerSnakeCase;
})();
(function(){
const styleToString = (styleObj) => Object.entries(styleObj || {}).map(([key, value]) => {
const kebabKey = key.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2').toLowerCase()
return `${kebabKey}: ${value}`
}).join('; ')
const toStyles = (obj) =>
Object.entries(obj || {}).reduce(
(previousValue, [key, value]) => ({
...previousValue,
[key.startsWith('moz') || key.startsWith('webkit') ? `-${key}` : key]: value,
}),
{},
)
window.toStyles = toStyles;
window.styleToString = styleToString;
})();
(function(){
})();
(function(){
var kebabToLowerSnakeCase = window.kebabToLowerSnakeCase;
function MakeDictionaries(dictionaries, defaultLocale) {
let state = {
localLocale: defaultLocale,
internalDictionaries: dictionaries,
dictionary: dictionaries[defaultLocale],
}
return {
getLocale: () => state.localLocale,
setLocale: (locale) => {
let newLocale = kebabToLowerSnakeCase(locale || '')
if (!locale) {
newLocale = 'en'
}
state.localLocale = newLocale
state.dictionary = state.internalDictionaries[newLocale]
},
t: () => state.dictionary,
tFrom: (locale) => state.internalDictionaries[locale],
text: () => state.dictionary,
textFrom: (locale) => state.internalDictionaries[locale],
}
}
var __ltng_default_export = {
MakeDictionaries
}
Object.assign(window, __ltng_default_export);
})();
(function(){
})();
(function(){
function randomIntFromInterval(min, max) { // min and max included
return Math.floor(Math.random() * (max - min + 1) + min)
}
window.randomIntFromInterval = randomIntFromInterval;
})();
(function(){
var randomIntFromInterval = window.randomIntFromInterval;
function randomStr(length) {
let result = ''
const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'
const charactersLength = characters.length
let counter = 0
while (counter < length) {
result += characters.charAt(Math.floor(Math.random() * charactersLength))
counter += 1
}
return result
}
function generatePass() {
let pass = ''
let str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' +
'abcdefghijklmnopqrstuvwxyz0123456789@#$'
for (let i = 1; i <= 8; i++) {
let char = Math.floor(Math.random()
* str.length + 1)
pass += str.charAt(char)
}
return pass
}
function randomStrWithPrefixWithSep(length, prefix, separator) {
return `${prefix}${separator}${randomStr(length)}`
}
function randomEmail() {
const prefix = randomStr(randomIntFromInterval(5, 22))
const domain = `${randomStr(randomIntFromInterval(5, 7))}.${randomStr(randomIntFromInterval(2, 3))}`
return `${prefix}@${domain}`
}
window.randomStr = randomStr;
window.generatePass = generatePass;
window.randomStrWithPrefixWithSep = randomStrWithPrefixWithSep;
window.randomEmail = randomEmail;
})();
(function(){
var ExternalServiceCallErr = window.ExternalServiceCallErr;
const defaultHeaders = {
Accept: 'application/json',
'Content-type': 'application/json; charset=UTF-8',
}
async function asyncDataParser(data) {
return !!data.body
? {
StatusCode: data.status,
Data: await data.json(),
Err: data.status >= 400 ? ExternalServiceCallErr() : null,
}
: {
StatusCode: data.status,
Data: null,
Err: data.status >= 400 ? ExternalServiceCallErr() : null,
}
}
function caughtHttpLocalResponseTreatmentError(err) {
return {
Err: err,
StatusCode: 422, // Unprocessable Content,
Data: null,
}
}
function generateInit(method, body, headers) {
const init = {
method: method,
headers: {
...defaultHeaders,
...headers,
},
}
if (body !== null && body !== undefined) {
init.body = JSON.stringify(body)
}
return init
}
async function AnyServerRequest(method, baseURL, url, body, headers) {
const init = generateInit(method, body, headers)
return fetch(baseURL + url, init)
.then(async (data) => {
return asyncDataParser(data)
})
.catch((error) => {
console.log(`caught ${method} call error: ${error}`)
return caughtHttpLocalResponseTreatmentError(error)
})
}
function HttpClient(config) {
const baseURL = config.baseURL
return {
Get: async function (url, headers) {
return AnyServerRequest('GET', baseURL, url, null, headers)
},
Post: async function (url, body, headers) {
return AnyServerRequest('POST', baseURL, url, body, headers)
},
Delete: async function (url, headers) {
return AnyServerRequest('DELETE', baseURL, url, null, headers)
},
Put: async function (url, body, headers) {
return AnyServerRequest('PUT', baseURL, url, body, headers)
},
Patch: async function (url, body, headers) {
return AnyServerRequest('PATCH', baseURL, url, body, headers)
},
Any: async function (method, url, body, headers) {
return AnyServerRequest(method, baseURL, url, body, headers)
},
}
}
window.HttpClient = HttpClient;
window.asyncDataParser = asyncDataParser;
window.defaultHeaders = defaultHeaders;
window.AnyServerRequest = AnyServerRequest;
})();
(function(){
function ExternalServiceCallErr() {
return {
cause: 'external service call',
message: 'request response',
name: 'external error',
}
}
function MapHttpResponseInfo(response) {
if (!response) {
return {
Err: {
cause: 'unknown',
message: 'invalid HttpResponseInfo<any> response ${response}',
name: 'invalid internal response',
},
Data: null,
StatusCode: 422,
}
}
return {
StatusCode: response.StatusCode || 0,
Data: response.Data || null,
Err: response.Err || null,
}
}
window.ExternalServiceCallErr = ExternalServiceCallErr;
window.MapHttpResponseInfo = MapHttpResponseInfo;
})();
(function(){
})();