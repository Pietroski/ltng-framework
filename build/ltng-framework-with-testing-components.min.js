(function() {
const module = { exports: {} };
const exports = module.exports;
const colors = {
reset: "\x1b[0m",
red: "\x1b[31m",
green: "\x1b[32m",
yellow: "\x1b[33m",
blue: "\x1b[34m",
magenta: "\x1b[35m",
cyan: "\x1b[36m",
white: "\x1b[37m",
gray: "\x1b[90m",
}
function color(text, colorName) {
return `${colors[colorName] || ""}${text}${colors.reset}`
}
module.exports = {
colors,
color,
}
const safeAssign = (target, source) => {
for (const key in source) {
try {
target[key] = source[key];
} catch (e) {
}
}
};
safeAssign(window, module.exports);
})();
(function() {
const module = { exports: {} };
const exports = module.exports;
const { color } = window
const stepDefinitions = []
const features = []
function Given(pattern, fn) {
stepDefinitions.push({ pattern, fn, type: "Given" })
}
function When(pattern, fn) {
stepDefinitions.push({ pattern, fn, type: "When" })
}
function Then(pattern, fn) {
stepDefinitions.push({ pattern, fn, type: "Then" })
}
function Feature(name, fn) {
const feature = { name, scenarios: [] }
features.push(feature)
const currentFeature = feature
global.Scenario = (name, body) => {
currentFeature.scenarios.push({ name, body })
}
fn()
}
async function run() {
console.log(color("\n=== Running Gherkin-like Tests ===\n", "magenta"))
const args = process.argv.slice(2)
let filterRegex = null
const runIndex = args.indexOf("--run")
if (runIndex !== -1 && args[runIndex + 1]) {
try {
filterRegex = new RegExp(args[runIndex + 1])
} catch (e) {
console.error(color(`Invalid filter regex: ${e.message}`, "red"))
process.exit(1)
}
}
let passed = 0
let failed = 0
for (const feature of features) {
const matchingScenarios = feature.scenarios.filter(s =>
!filterRegex || filterRegex.test(s.name) || filterRegex.test(feature.name)
)
if (matchingScenarios.length === 0) continue
console.log(color(`Feature: ${feature.name}`, "blue"))
for (const scenario of matchingScenarios) {
console.log(color(`  Scenario: ${scenario.name}`, "cyan"))
let scenarioFailed = false
const lines = scenario.body
.split("\n")
.map((l) => l.trim())
.filter((l) => l.length > 0)
const context = {} // Shared context for steps in a scenario
for (const line of lines) {
let matchFound = false
const cleanLine = line.replace(/^(Given|When|Then|And|But)\s+/i, "")
for (const stepDef of stepDefinitions) {
let match
if (typeof stepDef.pattern === "string") {
if (cleanLine === stepDef.pattern) {
match = []
} else if (cleanLine.startsWith(stepDef.pattern)) {
}
} else if (stepDef.pattern instanceof RegExp) {
match = cleanLine.match(stepDef.pattern)
}
if (match) {
matchFound = true
try {
const args = match.slice(1)
await stepDef.fn(context, ...args)
console.log(color(`    ${color("✔", "green")} ${line}`, "gray"))
} catch (e) {
console.error(
color(`    ${color("✘", "red")} ${line} \n      Error: ${e.message}`, "red")
)
scenarioFailed = true
}
break // Stop looking for definitions for this line
}
}
if (!matchFound) {
console.error(color(`    ? Undefined step: ${line}`, "yellow"))
scenarioFailed = true
}
if (scenarioFailed) break
}
if (scenarioFailed) {
failed++
} else {
passed++
}
}
}
console.log(color("\n=== Summary ===", "magenta"))
console.log(`Total Scenarios: ${passed + failed}`)
console.log(color(`Passed:          ${passed}`, "green"))
console.log(color(`Failed:          ${failed}`, failed > 0 ? "red" : "green"))
if (failed > 0) {
process.exitCode = 1
}
}
module.exports = {
Feature,
Given,
When,
Then,
run,
}
const safeAssign = (target, source) => {
for (const key in source) {
try {
target[key] = source[key];
} catch (e) {
}
}
};
safeAssign(window, module.exports);
})();
(function() {
const module = { exports: {} };
const exports = module.exports;
const { color } = window
const tests = []
let currentSuite = ""
function Group(name, fn) {
const previousSuite = currentSuite
currentSuite = `${previousSuite}[${name}] `
fn()
currentSuite = previousSuite
}
function Test(name, fn) {
const testName = `${currentSuite}${name}`
tests.push({ name: testName, fn })
}
async function run() {
let passed = 0
let failed = 0
let skipped = 0
const args = process.argv.slice(2)
let filterRegex = null
const runIndex = args.indexOf("--run")
if (runIndex !== -1 && args[runIndex + 1]) {
try {
filterRegex = new RegExp(args[runIndex + 1])
} catch (e) {
console.error(color(`Invalid filter regex: ${e.message}`, "red"))
process.exit(1)
}
}
console.log(color("\n=== Running Go-like Tests ===\n", "cyan"))
for (const test of tests) {
if (filterRegex && !filterRegex.test(test.name)) {
console.log(color(`    [SKIP] ${test.name}: Filtered out`, "yellow"))
skipped++
continue
}
let isFailed = false
let isSkipped = false
const t = {
name: test.name,
Assert: (condition, msg) => {
if (!condition) {
console.error(
color(`    [FAIL] ${test.name}: ${msg || "Assertion failed"}`, "red")
)
isFailed = true
}
},
Equal: (actual, expected, msg) => {
if (actual !== expected) {
console.error(
color(
`    [FAIL] ${test.name}: ${msg || "Equality check failed"}\n      Expected: ${expected}\n      Actual:   ${actual}`,
"red"
)
)
isFailed = true
}
},
Fail: () => {
isFailed = true
},
Skip: (msg) => {
console.log(color(`    [SKIP] ${test.name}: ${msg || ""}`, "yellow"))
isSkipped = true
},
Log: (...args) => {
console.log(`    [LOG]`, ...args)
},
}
try {
await test.fn(t)
} catch (e) {
console.error(color(`    [ERROR] ${test.name}: ${e.message}`, "red"))
isFailed = true
}
if (isSkipped) {
skipped++
} else if (isFailed) {
failed++
console.log(color(`FAIL: ${test.name}`, "red"))
} else {
passed++
console.log(color(`PASS: ${test.name}`, "green"))
}
}
console.log(color("\n=== Summary ===", "cyan"))
console.log(`Total:   ${tests.length}`)
console.log(color(`Passed:  ${passed}`, "green"))
console.log(color(`Failed:  ${failed}`, failed > 0 ? "red" : "green"))
console.log(color(`Skipped: ${skipped}`, skipped > 0 ? "yellow" : "gray"))
if (failed > 0) {
process.exitCode = 1
}
}
module.exports = {
Test,
Group,
run,
}
const safeAssign = (target, source) => {
for (const key in source) {
try {
target[key] = source[key];
} catch (e) {
}
}
};
safeAssign(window, module.exports);
})();
function generateUUIDv7() {
const timestamp = Date.now()
const value = new Uint8Array(16)
crypto.getRandomValues(value)
value[0] = (timestamp >> 40) & 0xff
value[1] = (timestamp >> 32) & 0xff
value[2] = (timestamp >> 24) & 0xff
value[3] = (timestamp >> 16) & 0xff
value[4] = (timestamp >> 8) & 0xff
value[5] = timestamp & 0xff
value[6] = (value[6] & 0x0f) | 0x70
value[8] = (value[8] & 0x3f) | 0x80
return [...value].map((b, i) => {
const hex = b.toString(16).padStart(2, '0')
return (i === 4 || i === 6 || i === 8 || i === 10) ? `-${hex}` : hex
}).join('')
}
window.generateUUIDv7 = generateUUIDv7
window.loadCSS = (href) => {
if (!document.querySelector(`link[href="${href}"]`)) {
const link = document.createElement('link')
link.rel = 'stylesheet'
link.href = href
document.head.appendChild(link)
}
}
Object.defineProperty(window, 'Body', {
get: () => document.body
})
window.TextNode = (text) => document.createTextNode(text)
let isHydrated = false
HTMLBodyElement.prototype.render = function (...children) {
if (!isHydrated) {
while (this.firstChild) {
this.removeChild(this.firstChild)
}
isHydrated = true
}
render(this, ...children)
}
HTMLElement.prototype.render = function (...children) {
render(this, ...children)
}
HTMLUnknownElement.prototype.render = function (...children) {
render(this, ...children)
}
function render(parent, ...children) {
children.forEach(child => {
if (typeof child === 'string' || typeof child === 'number') {
parent.appendChild(TextNode(child))
} else if (child instanceof Node) {
parent.appendChild(child)
} else if (Array.isArray(child)) {
child.forEach(c => render(parent, c)) // child.forEach(appendChild) old and wrong
} else if (child === null || child === undefined) {
} else {
parent.appendChild(TextNode(String(child)))
}
})
}
function createElement(tag, props, ...children) {
const element = document.createElement(tag)
if (props) {
for (const [key, value] of Object.entries(props)) {
if (key.startsWith('on') && typeof value === 'function') {
const eventName = key.substring(2).toLowerCase()
element.addEventListener(eventName, value)
} else {
element.setAttribute(key, value)
}
}
} else {
element.setAttribute('class', tag.toLowerCase())
element.setAttribute('id', generateUUIDv7())
}
element.render(children)
return element
}
const tags = [
'div', 'span', 'header', 'footer', 'main', 'section', 'article',
'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'a', 'button', 'input',
'label', 'ul', 'ol', 'li', 'img', 'form', 'nav'
]
tags.forEach(tagName => {
window[tagName] = (props, ...children) => {
return createElement(tagName, props, ...children)
}
})
window.overlayModal = (props, content) => {
const overlay = div({
...props,
style: 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center; z-index: 1000;'
},
div({
style: 'background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); min-width: 300px; display: flex; flex-direction: column; gap: 15px;'
},
div({ style: 'font-size: 1.1em; color: #333;' }, content),
div({ style: 'display: flex; justify-content: flex-end;' },
button({
onClick: (e) => {
const overlayEl = e.target.closest('[style*="position: fixed"]')
if (overlayEl) overlayEl.remove()
},
style: 'padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;'
}, 'Close')
)
)
)
Body.render(overlay)
}
window.createStore = (initialState, options = {}) => {
let state = initialState
const listeners = new Set()
const persistKey = options.persist
if (persistKey) {
const saved = localStorage.getItem(persistKey)
if (saved) {
try {
state = { ...state, ...JSON.parse(saved) }
} catch (e) {
console.error('Failed to parse saved state', e)
}
}
}
const getState = () => state
const setState = (partialState) => {
state = { ...state, ...partialState }
if (persistKey) {
localStorage.setItem(persistKey, JSON.stringify(state))
}
listeners.forEach(listener => listener(state))
}
const subscribe = (listener) => {
listeners.add(listener)
listener(state)
return () => listeners.delete(listener)
}
return { getState, setState, subscribe }
}
(function() {
function styleToString(styleObj) {
return Object.entries(styleObj || {}).map(([key, value]) => {
const kebabKey = key.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2').toLowerCase()
return `${kebabKey}: ${value}`
}).join('; ')
}
window.loadCSS('/pkg/styles/theme.css')
window.loadCSS('/pkg/components/button.css')
window.Button = (props, ...children) => {
const { variant = 'default', disabled, className = '', style, ...rest } = props || {}
const classes = ['ltng-button']
if (variant === 'primary') {
classes.push('ltng-button--primary')
} else if (variant === 'secondary') {
classes.push('ltng-button--secondary')
}
if (disabled) {
}
if (className) {
classes.push(className)
}
const buttonProps = {
...rest,
class: classes.join(' ')
}
if (style) buttonProps.style = typeof style === 'object' ? styleToString(style) : style // Pass through inline styles
if (disabled) {
buttonProps.disabled = true
}
return button(buttonProps, ...children)
}
Button.Primary = (props, ...children) => Button({ ...props, variant: 'primary' }, ...children)
Button.Secondary = (props, ...children) => Button({ ...props, variant: 'secondary' }, ...children)
})();
(function() {
function styleToString(styleObj) {
return Object.entries(styleObj || {}).map(([key, value]) => {
const kebabKey = key.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2').toLowerCase()
return `${kebabKey}: ${value}`
}).join('; ')
}
window.loadCSS('/pkg/styles/theme.css')
window.loadCSS('/pkg/components/card.css')
window.Card = (props, ...children) => {
const { darkMode = true, className = '', style, ...rest } = props || {}
const classes = ['ltng-card']
if (darkMode) classes.push('ltng-card--dark')
else classes.push('ltng-card--light')
if (className) classes.push(className)
return div({
...rest,
class: classes.join(' '),
style: typeof style === 'object' ? styleToString(style) : style
}, ...children)
}
const CardCloseButton = (props) => {
const { onClick, style, className = '' } = props
const classes = ['ltng-card-close-btn']
if (className) classes.push(className)
return div({
class: classes.join(' '),
style: typeof style === 'object' ? styleToString(style) : style,
onClick: onClick
}, 'X')
}
Card.Closable = (props, ...children) => {
const { initialCardState = true, onCloseClick, closeBtnStyle, ...rest } = props || {}
return Card(rest,
CardCloseButton({ onClick: onCloseClick, style: closeBtnStyle }),
...children
)
}
Card.SelfClosable = (props, ...children) => {
const id = `card-${Math.random().toString(36).substring(2, 11)}`
const closeHandler = (e) => {
const el = document.getElementById(id)
if (el) el.remove()
if (props.onCloseClick) props.onCloseClick(e)
}
return Card({ ...props, id },
CardCloseButton({ onClick: closeHandler }),
...children
)
}
})();
(function() {
function styleToString(styleObj) {
return Object.entries(styleObj || {}).map(([key, value]) => {
const kebabKey = key.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2').toLowerCase()
return `${kebabKey}: ${value}`
}).join('; ')
}
window.FlexStyleOpts = {
FD: {
Row: { flexDirection: 'row' },
Column: { flexDirection: 'column' },
RowReverse: { flexDirection: 'row-reverse' },
ColumnReverse: { flexDirection: 'column-reverse' },
},
JC: {
Center: { justifyContent: 'center' },
FlexStart: { justifyContent: 'flex-start' },
FlexEnd: { justifyContent: 'flex-end' },
SpaceAround: { justifyContent: 'space-around' },
SpaceBetween: { justifyContent: 'space-between' },
SpaceEvenly: { justifyContent: 'space-evenly' },
},
AC: {
Center: { alignContent: 'center' },
FlexStart: { alignContent: 'flex-start' },
FlexEnd: { alignContent: 'flex-end' },
Stretch: { alignContent: 'stretch' },
SpaceAround: { alignContent: 'space-around' },
SpaceBetween: { alignContent: 'space-between' },
},
AI: {
Center: { alignItems: 'center' },
FlexStart: { alignItems: 'flex-start' },
FlexEnd: { alignItems: 'flex-end' },
Stretch: { alignItems: 'stretch' },
},
}
window.loadCSS('/pkg/styles/theme.css')
window.loadCSS('/pkg/components/containers.css')
window.Div = (props, ...children) => {
const { className = '', style, ...rest } = props || {}
const classes = ['ltng-container']
if (className) classes.push(className)
const containerProps = {
...rest,
class: classes.join(' ')
}
if (style) containerProps.style = typeof style === 'object' ? styleToString(style) : style
return div(containerProps, ...children)
}
Div.Flex = (props, ...children) => {
const { className = '', style, ...rest } = props || {}
const classes = ['ltng-container', 'ltng-container--flex']
if (className) classes.push(className)
const containerProps = {
...rest,
class: classes.join(' ')
}
if (style) containerProps.style = typeof style === 'object' ? styleToString(style) : style
return div(containerProps, ...children)
}
Div.Grid = (props, ...children) => {
const { className = '', style, ...rest } = props || {}
const classes = ['ltng-container', 'ltng-container--grid']
if (className) classes.push(className)
const containerProps = {
...rest,
class: classes.join(' ')
}
if (style) containerProps.style = typeof style === 'object' ? styleToString(style) : style
return div(containerProps, ...children)
}
})();
(function() {
function styleToString(styleObj) {
return Object.entries(styleObj || {}).map(([key, value]) => {
const kebabKey = key.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2').toLowerCase()
return `${kebabKey}: ${value}`
}).join('; ')
}
window.loadCSS('/pkg/styles/theme.css')
window.loadCSS('/pkg/components/footer.css')
window.Footer = (props, ...children) => {
const { className = '', style, ...rest } = props || {}
const classes = ['ltng-footer']
if (className) classes.push(className)
const footerProps = {
...rest,
class: classes.join(' ')
}
if (style) footerProps.style = typeof style === 'object' ? styleToString(style) : style
return footer(footerProps, ...children)
}
})();
(function() {
const Input = window.Input;
const Button = window.Button;
const Typography = window.Typography;
const Div = window.Div;
function styleToString(styleObj) {
return Object.entries(styleObj || {}).map(([key, value]) => {
const kebabKey = key.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2').toLowerCase()
return `${kebabKey}: ${value}`
}).join('; ')
}
window.loadCSS('/pkg/styles/theme.css')
window.loadCSS('/pkg/components/form.css')
window.createFormStore = (initialState = {}, config = {}) => {
const store = window.createStore ? window.createStore(initialState) : (() => {
let state = initialState
const listeners = new Set()
return {
getState: () => state,
setState: (update) => {
state = { ...state, ...update }
listeners.forEach(l => l(state))
},
subscribe: (l) => {
listeners.add(l)
return () => listeners.delete(l)
}
}
})()
return {
...store,
config, // Expose config
GetFormState: () => store.getState(),
GetFormItemStateByKey: (key) => store.getState()[key],
SetFormItemState: (item) => {
const currentState = store.getState()
store.setState({
[item.id]: {
...currentState[item.id],
...item
}
})
},
ResetFormState: () => {
store.setState(initialState)
}
}
}
window.Form = (props, ...children) => {
const { style, onSubmit, store, className = '', ...rest } = props || {}
const classes = ['ltng-form']
if (className) classes.push(className)
const form = document.createElement('form')
Object.entries(rest).forEach(([key, value]) => {
if (key === 'class') return // Handle class separately
else form.setAttribute(key, value)
})
form.className = classes.join(' ')
form.style.cssText = styleToString(style)
form.onsubmit = (e) => {
e.preventDefault()
if (onSubmit && store) {
onSubmit({ ...e, formObject: store.GetFormState() })
}
}
children.forEach(child => {
if (child) form.appendChild(child)
})
return form
}
Form.Field = (props) => {
const {
store,
fieldKey,
label,
isSecret,
validation,
isRequired,
style,
darkMode, // Explicit prop overrides store config
...rest
} = props
if (!store) {
console.error('Form.Field requires a "store" prop.')
return Div({}, 'Error: Missing store')
}
const effectiveDarkMode = darkMode !== undefined
? darkMode
: store.config?.darkMode
const currentState = store.GetFormState()
if (!currentState[fieldKey]) {
store.SetFormItemState({
id: fieldKey,
value: '',
errValue: null,
required: isRequired
})
}
const errorSpan = Typography.Span({
class: 'ltng-form-error-msg'
}, '')
const handleInput = (e) => {
const value = e.target.value
let err = null
if (isRequired && !value) {
err = new Error('Required field')
} else if (validation) {
err = validation({ value })
}
store.SetFormItemState({
id: fieldKey,
value,
errValue: err,
required: isRequired
})
}
const inputProps = {
...rest,
id: fieldKey,
placeholder: label,
onChange: handleInput, // Input component maps this to onInput
style: style,
darkMode: effectiveDarkMode
}
const inputComponent = isSecret ? Input.Secret(inputProps) : Input(inputProps)
store.subscribe((state) => {
const item = state[fieldKey]
if (item) {
const actualInput = inputComponent.querySelector('input')
if (actualInput && actualInput.value !== item.value) {
actualInput.value = item.value || ''
}
errorSpan.textContent = item.errValue ? item.errValue.message : ''
}
})
return Div({ class: 'ltng-form-field-container' },
inputComponent,
errorSpan
)
}
Form.FieldSecret = (props) => Form.Field({ ...props, isSecret: true })
Form.PrimaryButton = (props, ...children) => {
const { store, disabled, ...rest } = props
const btn = Button.Primary({
...rest,
type: 'submit',
disabled: disabled // Initial state
}, ...children)
if (store) {
store.subscribe((state) => {
let shouldDisable = false
Object.values(state).forEach(item => {
if (!item || typeof item !== 'object' || Array.isArray(item)) return
if (item.required && (!item.value || item.errValue)) {
shouldDisable = true
}
if (item.errValue) {
shouldDisable = true
}
})
if (btn.tagName === 'BUTTON') {
btn.disabled = shouldDisable || disabled
} else {
const actualBtn = btn.querySelector('button')
if (actualBtn) actualBtn.disabled = shouldDisable || disabled
}
})
}
return btn
}
Form.SecondaryButton = (props, ...children) => {
const { store, ...rest } = props
return Button.Secondary({
...rest,
type: 'button', // Prevent submit
onClick: (e) => {
e.preventDefault()
if (store) store.ResetFormState()
if (props.onClick) props.onClick(e)
}
}, ...children)
}
})();
(function() {
})();
(function() {
window.loadCSS('/pkg/styles/theme.css')
window.loadCSS('/pkg/components/input.css')
window.Input = (props) => {
const {
id,
placeholder,
type = 'text',
isSecret,
darkMode = true,
style,
onChange,
onFocus,
onBlur,
value,
className = '',
...rest
} = props || {}
const inputId = id || `input-${Math.random().toString(36).substring(2, 11)}`
let currentType = isSecret ? 'password' : type
const inputClasses = ['ltng-input-field']
if (darkMode) inputClasses.push('ltng-input-field--dark')
else inputClasses.push('ltng-input-field--light')
if (isSecret) inputClasses.push('ltng-input-field--secret')
const inputEl = input({
id: inputId,
type: currentType,
value: value || '',
placeholder: '', // Placeholder is handled by label
class: inputClasses.join(' '),
onInput: onChange, // Map onChange to onInput for real-time updates
onFocus: onFocus,
onBlur: onBlur,
...rest
})
const labelClasses = ['ltng-input-label']
if (darkMode) labelClasses.push('ltng-input-label--dark')
else labelClasses.push('ltng-input-label--light')
const children = [
window.label({
class: labelClasses.join(' '),
for: inputId
}, placeholder || ''),
inputEl
]
if (isSecret) {
const toggleClasses = ['ltng-input-secret-toggle']
if (darkMode) toggleClasses.push('ltng-input-secret-toggle--dark')
else toggleClasses.push('ltng-input-secret-toggle--light')
const toggleBtn = div({
class: toggleClasses.join(' '),
onClick: (e) => {
const input = document.getElementById(inputId)
if (input) {
if (input.type === 'password') {
input.type = 'text'
e.target.textContent = 'Hide' // Simple text for now, could be icon
} else {
input.type = 'password'
e.target.textContent = 'Show'
}
}
}
}, 'Show')
children.push(toggleBtn)
}
const wrapperClasses = ['ltng-input-wrapper']
if (darkMode) wrapperClasses.push('ltng-input-wrapper--dark')
else wrapperClasses.push('ltng-input-wrapper--light')
if (className) wrapperClasses.push(className)
return div({
class: wrapperClasses.join(' '),
style: style
}, ...children)
}
Input.Secret = (props) => Input({ ...props, isSecret: true })
})();
(function() {
const Card = window.Card;
window.loadCSS('/pkg/styles/theme.css')
window.loadCSS('/pkg/components/modal.css')
window.Modal = (props, ...children) => {
const {
isOpen,
onClose,
darkMode = true,
style,
closeFromOutside = true,
className = '',
...rest
} = props || {}
if (!isOpen) return null
const backgroundOverlay = div({
class: 'ltng-modal-overlay',
onClick: (e) => {
if (closeFromOutside && onClose) {
onClose(e)
}
}
})
const contentClasses = ['ltng-modal-content']
if (darkMode) contentClasses.push('ltng-modal-content--dark')
else contentClasses.push('ltng-modal-content--light')
const content = Card.Closable({
darkMode,
onCloseClick: onClose,
className: contentClasses.join(' '),
style: style,
...rest
}, ...children)
const containerClasses = ['ltng-modal-container']
if (className) containerClasses.push(className)
const baseContainer = div({
class: containerClasses.join(' ')
}, backgroundOverlay, content)
return baseContainer
}
})();
(function() {
const Card = window.Card;
const Div = window.Div;
const Typography = window.Typography;
function styleToString(styleObj) {
return Object.entries(styleObj || {}).map(([key, value]) => {
const kebabKey = key.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2').toLowerCase()
return `${kebabKey}: ${value}`
}).join('; ')
}
const Colours = {
DarkGoldenRod: '#b8860b',
DarkGreen: '#006400',
DarkRed: '#8b0000',
Whitesmoke: 'whitesmoke',
Primary: '#1976d2',
DarkGray: '#333',
}
const createToastStore = () => {
let toasts = []
const listeners = new Set()
let counter = 0
const notify = () => listeners.forEach(l => l(toasts))
const remove = (id) => {
toasts = toasts.filter(t => t.id !== id)
notify()
}
const add = (toast) => {
const id = ++counter
const newToast = { ...toast, id }
toasts = [...toasts, newToast]
notify()
if (newToast.duration !== 0) {
setTimeout(() => {
remove(id)
}, newToast.duration || 5000)
}
return id
}
return {
getToasts: () => toasts,
subscribe: (l) => {
listeners.add(l)
return () => listeners.delete(l)
},
add,
remove
}
}
window.loadCSS('/pkg/styles/theme.css')
window.loadCSS('/pkg/components/toast.css')
window.toastStore = createToastStore()
window.Toast = {
Container: (props) => {
const { store = toastStore, darkMode = true } = props || {}
const container = Div({
class: 'ltng-toast-container'
})
const renderToasts = (list) => {
container.innerHTML = '' // Clear current
list.forEach((t, index) => {
const classes = ['ltng-toast-card']
if (t.type === 'warning') classes.push('ltng-toast-card--warning')
else if (t.type === 'success') classes.push('ltng-toast-card--success')
else if (t.type === 'failure') classes.push('ltng-toast-card--failure')
else {
if (darkMode) classes.push('ltng-toast-card--default-dark')
else classes.push('ltng-toast-card--default-light')
}
const toastCard = Card.Closable({
darkMode,
onCloseClick: () => store.remove(t.id),
className: classes.join(' '),
style: {
marginTop: `${index * 110}px`,
zIndex: 2000 + index
},
closeBtnStyle: { borderColor: t.type === 'failure' ? 'white' : 'currentColor' }
},
Typography.Paragraph({ style: { margin: 0, color: 'inherit' } }, t.message)
)
container.appendChild(toastCard)
})
}
store.subscribe(renderToasts)
return container
},
show: (message, options = {}) => toastStore.add({ message, ...options }),
success: (message, options = {}) => toastStore.add({ message, type: 'success', ...options }),
warning: (message, options = {}) => toastStore.add({ message, type: 'warning', ...options }),
failure: (message, options = {}) => toastStore.add({ message, type: 'failure', ...options }),
}
})();
(function() {
function styleToString(styleObj) {
return Object.entries(styleObj || {}).map(([key, value]) => {
const kebabKey = key.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2').toLowerCase()
return `${kebabKey}: ${value}`
}).join('; ')
}
window.loadCSS('/pkg/styles/theme.css')
window.loadCSS('/pkg/components/typography.css')
const createTypographyComponent = (tag, variantClass) => (props, ...children) => {
const { darkMode = true, className = '', style, ...rest } = props || {}
const classes = ['ltng-typography']
if (variantClass) {
classes.push(variantClass)
}
if (darkMode) {
classes.push('ltng-typography--dark')
} else {
classes.push('ltng-typography--light')
}
if (className) {
classes.push(className)
}
const elementCreator = window[tag] || ((p, ...c) => {
return window.createElement(tag.toLowerCase(), p, ...c)
})
return elementCreator({
...rest,
class: classes.join(' '),
style: typeof style === 'object' ? styleToString(style) : style
}, ...children)
}
window.Typography = (props, ...children) => {
return createTypographyComponent('div')(props, ...children)
}
Typography.H1 = createTypographyComponent('h1', 'ltng-typography-h1')
Typography.H2 = createTypographyComponent('h2', 'ltng-typography-h2')
Typography.H3 = createTypographyComponent('h3', 'ltng-typography-h3')
Typography.H4 = createTypographyComponent('h4', 'ltng-typography-h4')
Typography.H5 = createTypographyComponent('h5', 'ltng-typography-h5')
Typography.Paragraph = createTypographyComponent('p', 'ltng-typography-p')
Typography.Span = createTypographyComponent('span', 'ltng-typography-span')
})();