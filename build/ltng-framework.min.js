function generateUUIDv7() {
const timestamp = Date.now()
const value = new Uint8Array(16)
crypto.getRandomValues(value)
value[0] = (timestamp >> 40) & 0xff
value[1] = (timestamp >> 32) & 0xff
value[2] = (timestamp >> 24) & 0xff
value[3] = (timestamp >> 16) & 0xff
value[4] = (timestamp >> 8) & 0xff
value[5] = timestamp & 0xff
value[6] = (value[6] & 0x0f) | 0x70
value[8] = (value[8] & 0x3f) | 0x80
return [...value].map((b, i) => {
const hex = b.toString(16).padStart(2, '0')
return (i === 4 || i === 6 || i === 8 || i === 10) ? `-${hex}` : hex
}).join('')
}
window.generateUUIDv7 = generateUUIDv7
window.loadCSS = (href) => {
if (!document.querySelector(`link[href="${href}"]`)) {
const link = document.createElement('link')
link.rel = 'stylesheet'
link.href = href
document.head.appendChild(link)
}
}
Object.defineProperty(window, 'Body', {
get: () => document.body
})
window.TextNode = (text) => document.createTextNode(text)
let isHydrated = false
HTMLBodyElement.prototype.render = function (...children) {
if (!isHydrated) {
while (this.firstChild) {
this.removeChild(this.firstChild)
}
isHydrated = true
}
render(this, ...children)
}
HTMLElement.prototype.render = function (...children) {
render(this, ...children)
}
HTMLUnknownElement.prototype.render = function (...children) {
render(this, ...children)
}
function render(parent, ...children) {
children.forEach(child => {
if (typeof child === 'string' || typeof child === 'number') {
parent.appendChild(TextNode(child))
} else if (child instanceof Node) {
parent.appendChild(child)
} else if (Array.isArray(child)) {
child.forEach(c => render(parent, c)) // child.forEach(appendChild) old and wrong
} else if (child === null || child === undefined) {
} else {
parent.appendChild(TextNode(String(child)))
}
})
}
function createElement(tag, props, ...children) {
const element = document.createElement(tag)
if (props) {
for (const [key, value] of Object.entries(props)) {
if (key.startsWith('on') && typeof value === 'function') {
const eventName = key.substring(2).toLowerCase()
element.addEventListener(eventName, value)
} else {
element.setAttribute(key, value)
}
}
} else {
element.setAttribute('class', tag.toLowerCase())
element.setAttribute('id', generateUUIDv7())
}
element.render(children)
return element
}
const tags = [
'div', 'span', 'header', 'footer', 'main', 'section', 'article',
'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'a', 'button', 'input',
'label', 'ul', 'ol', 'li', 'img', 'form', 'nav'
]
tags.forEach(tagName => {
window[tagName] = (props, ...children) => {
return createElement(tagName, props, ...children)
}
})
window.overlayModal = (props, content) => {
const overlay = div({
...props,
style: 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center; z-index: 1000;'
},
div({
style: 'background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); min-width: 300px; display: flex; flex-direction: column; gap: 15px;'
},
div({ style: 'font-size: 1.1em; color: #333;' }, content),
div({ style: 'display: flex; justify-content: flex-end;' },
button({
onClick: (e) => {
const overlayEl = e.target.closest('[style*="position: fixed"]')
if (overlayEl) overlayEl.remove()
},
style: 'padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;'
}, 'Close')
)
)
)
Body.render(overlay)
}
window.createStore = (initialState, options = {}) => {
let state = initialState
const listeners = new Set()
const persistKey = options.persist
if (persistKey) {
const saved = localStorage.getItem(persistKey)
if (saved) {
try {
state = { ...state, ...JSON.parse(saved) }
} catch (e) {
console.error('Failed to parse saved state', e)
}
}
}
const getState = () => state
const setState = (partialState) => {
state = { ...state, ...partialState }
if (persistKey) {
localStorage.setItem(persistKey, JSON.stringify(state))
}
listeners.forEach(listener => listener(state))
}
const subscribe = (listener) => {
listeners.add(listener)
listener(state)
return () => listeners.delete(listener)
}
return { getState, setState, subscribe }
}