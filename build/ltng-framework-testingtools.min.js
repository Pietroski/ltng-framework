(function(){
function generateUUIDv7() {
const timestamp = Date.now()
const value = new Uint8Array(16)
crypto.getRandomValues(value)
value[0] = (timestamp >> 40) & 0xff
value[1] = (timestamp >> 32) & 0xff
value[2] = (timestamp >> 24) & 0xff
value[3] = (timestamp >> 16) & 0xff
value[4] = (timestamp >> 8) & 0xff
value[5] = timestamp & 0xff
value[6] = (value[6] & 0x0f) | 0x70
value[8] = (value[8] & 0x3f) | 0x80
return [...value].map((b, i) => {
const hex = b.toString(16).padStart(2, '0')
return (i === 4 || i === 6 || i === 8 || i === 10) ? `-${hex}` : hex
}).join('')
}
window.generateUUIDv7 = generateUUIDv7
window.loadCSS = (href) => {
if (!document.querySelector(`link[href="${href}"]`)) {
const link = document.createElement('link')
link.rel = 'stylesheet'
link.href = href
document.head.appendChild(link)
}
}
Object.defineProperty(window, 'Body', {
get: () => document.body
})
window.TextNode = (text) => document.createTextNode(text)
let isHydrated = false
HTMLBodyElement.prototype.render = function (...children) {
if (!isHydrated) {
while (this.firstChild) {
this.removeChild(this.firstChild)
}
isHydrated = true
}
render(this, ...children)
}
HTMLElement.prototype.render = function (...children) {
render(this, ...children)
}
HTMLUnknownElement.prototype.render = function (...children) {
render(this, ...children)
}
function render(parent, ...children) {
children.forEach(child => {
if (typeof child === 'string' || typeof child === 'number') {
parent.appendChild(TextNode(child))
} else if (child instanceof Node) {
parent.appendChild(child)
} else if (Array.isArray(child)) {
child.forEach(c => render(parent, c)) // child.forEach(appendChild) old and wrong
} else if (child === null || child === undefined) {
} else {
parent.appendChild(TextNode(String(child)))
}
})
}
function createElement(tag, props, ...children) {
const element = document.createElement(tag)
if (props) {
for (const [key, value] of Object.entries(props)) {
if (key.startsWith('on') && typeof value === 'function') {
const eventName = key.substring(2).toLowerCase()
element.addEventListener(eventName, value)
} else {
element.setAttribute(key, value)
}
}
} else {
element.setAttribute('class', tag.toLowerCase())
element.setAttribute('id', generateUUIDv7())
}
element.render(children)
return element
}
const tags = [
'div', 'span', 'header', 'footer', 'main', 'section', 'article',
'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'a', 'button', 'input',
'label', 'ul', 'ol', 'li', 'img', 'form', 'nav'
]
tags.forEach(tagName => {
window[tagName] = (props, ...children) => {
return createElement(tagName, props, ...children)
}
})
window.overlayModal = (props, content) => {
const overlay = div({
...props,
style: 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center; z-index: 1000;'
},
div({
style: 'background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); min-width: 300px; display: flex; flex-direction: column; gap: 15px;'
},
div({ style: 'font-size: 1.1em; color: #333;' }, content),
div({ style: 'display: flex; justify-content: flex-end;' },
button({
onClick: (e) => {
const overlayEl = e.target.closest('[style*="position: fixed"]')
if (overlayEl) overlayEl.remove()
},
style: 'padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;'
}, 'Close')
)
)
)
Body.render(overlay)
}
window.createStore = (initialState, options = {}) => {
let state = initialState
const listeners = new Set()
const persistKey = options.persist
if (persistKey) {
const saved = localStorage.getItem(persistKey)
if (saved) {
try {
state = { ...state, ...JSON.parse(saved) }
} catch (e) {
console.error('Failed to parse saved state', e)
}
}
}
const getState = () => state
const setState = (partialState) => {
state = { ...state, ...partialState }
if (persistKey) {
localStorage.setItem(persistKey, JSON.stringify(state))
}
listeners.forEach(listener => listener(state))
}
const subscribe = (listener) => {
listeners.add(listener)
listener(state)
return () => listeners.delete(listener)
}
return { getState, setState, subscribe }
}
})();
(function(){
const colors = {
reset: "\x1b[0m",
red: "\x1b[31m",
green: "\x1b[32m",
yellow: "\x1b[33m",
blue: "\x1b[34m",
magenta: "\x1b[35m",
cyan: "\x1b[36m",
white: "\x1b[37m",
gray: "\x1b[90m",
}
function color(text, colorName) {
return `${colors[colorName] || ""}${text}${colors.reset}`
}
window.colors = colors;
window.color = color;
})();
(function(){
var color = window.color;
const stepDefinitions = []
const features = []
function Given(pattern, fn) {
stepDefinitions.push({ pattern, fn, type: "Given" })
}
function When(pattern, fn) {
stepDefinitions.push({ pattern, fn, type: "When" })
}
function Then(pattern, fn) {
stepDefinitions.push({ pattern, fn, type: "Then" })
}
function Feature(name, fn) {
const feature = { name, scenarios: [] }
features.push(feature)
const currentFeature = feature
global.Scenario = (name, body) => {
currentFeature.scenarios.push({ name, body })
}
fn()
}
async function run() {
console.log(color("\n=== Running Gherkin-like Tests ===\n", "magenta"))
const args = process.argv.slice(2)
let filterRegex = null
const runIndex = args.indexOf("--run")
if (runIndex !== -1 && args[runIndex + 1]) {
try {
filterRegex = new RegExp(args[runIndex + 1])
} catch (e) {
console.error(color(`Invalid filter regex: ${e.message}`, "red"))
process.exit(1)
}
}
let passed = 0
let failed = 0
for (const feature of features) {
const matchingScenarios = feature.scenarios.filter(s =>
!filterRegex || filterRegex.test(s.name) || filterRegex.test(feature.name)
)
if (matchingScenarios.length === 0) continue
console.log(color(`Feature: ${feature.name}`, "blue"))
for (const scenario of matchingScenarios) {
console.log(color(`  Scenario: ${scenario.name}`, "cyan"))
let scenarioFailed = false
const lines = scenario.body
.split("\n")
.map((l) => l.trim())
.filter((l) => l.length > 0)
const context = {} // Shared context for steps in a scenario
for (const line of lines) {
let matchFound = false
const cleanLine = line.replace(/^(Given|When|Then|And|But)\s+/i, "")
for (const stepDef of stepDefinitions) {
let match
if (typeof stepDef.pattern === "string") {
if (cleanLine === stepDef.pattern) {
match = []
} else if (cleanLine.startsWith(stepDef.pattern)) {
}
} else if (stepDef.pattern instanceof RegExp) {
match = cleanLine.match(stepDef.pattern)
}
if (match) {
matchFound = true
try {
const args = match.slice(1)
await stepDef.fn(context, ...args)
console.log(color(`    ${color("✔", "green")} ${line}`, "gray"))
} catch (e) {
console.error(
color(`    ${color("✘", "red")} ${line} \n      Error: ${e.message}`, "red")
)
scenarioFailed = true
}
break // Stop looking for definitions for this line
}
}
if (!matchFound) {
console.error(color(`    ? Undefined step: ${line}`, "yellow"))
scenarioFailed = true
}
if (scenarioFailed) break
}
if (scenarioFailed) {
failed++
} else {
passed++
}
}
}
console.log(color("\n=== Summary ===", "magenta"))
console.log(`Total Scenarios: ${passed + failed}`)
console.log(color(`Passed:          ${passed}`, "green"))
console.log(color(`Failed:          ${failed}`, failed > 0 ? "red" : "green"))
if (failed > 0) {
process.exitCode = 1
}
}
export default {
Feature,
Given,
When,
Then,
run,
}
})();
(function(){
var color = window.color;
const tests = []
let currentSuite = ""
async function Group(name, fn) {
const previousSuite = currentSuite
currentSuite = `${previousSuite}[${name}] `
await fn()
currentSuite = previousSuite
}
function Test(name, fn) {
const testName = `${currentSuite}${name}`
tests.push({ name: testName, fn })
}
async function run() {
let passed = 0
let failed = 0
let skipped = 0
const args = process.argv.slice(2)
let filterRegex = null
const runIndex = args.indexOf("--run")
if (runIndex !== -1 && args[runIndex + 1]) {
try {
filterRegex = new RegExp(args[runIndex + 1])
} catch (e) {
console.error(color(`Invalid filter regex: ${e.message}`, "red"))
process.exit(1)
}
}
console.log(color("\n=== Running Go-like Tests ===\n", "cyan"))
for (const test of tests) {
if (filterRegex && !filterRegex.test(test.name)) {
console.log(color(`    [SKIP] ${test.name}: Filtered out`, "yellow"))
skipped++
continue
}
let isFailed = false
let isSkipped = false
const t = {
name: test.name,
Assert: (condition, msg) => {
if (!condition) {
console.error(
color(`    [FAIL] ${test.name}: ${msg || "Assertion failed"}`, "red")
)
isFailed = true
}
},
Equal: (actual, expected, msg) => {
if (actual !== expected) {
console.error(
color(
`    [FAIL] ${test.name}: ${msg || "Equality check failed"}\n      Expected: ${expected}\n      Actual:   ${actual}`,
"red"
)
)
isFailed = true
}
},
Fail: () => {
isFailed = true
},
Skip: (msg) => {
console.log(color(`    [SKIP] ${test.name}: ${msg || ""}`, "yellow"))
isSkipped = true
},
Log: (...args) => {
console.log(`    [LOG]`, ...args)
},
}
try {
await test.fn(t)
} catch (e) {
console.error(color(`    [ERROR] ${test.name}: ${e.message}`, "red"))
isFailed = true
}
if (isSkipped) {
skipped++
} else if (isFailed) {
failed++
console.log(color(`FAIL: ${test.name}`, "red"))
} else {
passed++
console.log(color(`PASS: ${test.name}`, "green"))
}
}
console.log(color("\n=== Summary ===", "cyan"))
console.log(`Total:   ${tests.length}`)
console.log(color(`Passed:  ${passed}`, "green"))
console.log(color(`Failed:  ${failed}`, failed > 0 ? "red" : "green"))
console.log(color(`Skipped: ${skipped}`, skipped > 0 ? "yellow" : "gray"))
if (failed > 0) {
process.exitCode = 1
}
}
window.Test = Test;
window.Group = Group;
window.run = run;
export default {
Test,
Group,
run,
}
})();