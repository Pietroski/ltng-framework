(function(){
const colors = {
reset: "\x1b[0m",
red: "\x1b[31m",
green: "\x1b[32m",
yellow: "\x1b[33m",
blue: "\x1b[34m",
magenta: "\x1b[35m",
cyan: "\x1b[36m",
white: "\x1b[37m",
gray: "\x1b[90m",
}
function color(text, colorName) {
return `${colors[colorName] || ""}${text}${colors.reset}`
}
window.colors = colors;
window.color = color;
})();
(function(){
var color = window.color;
const stepDefinitions = []
const features = []
function Given(pattern, fn) {
stepDefinitions.push({ pattern, fn, type: "Given" })
}
function When(pattern, fn) {
stepDefinitions.push({ pattern, fn, type: "When" })
}
function Then(pattern, fn) {
stepDefinitions.push({ pattern, fn, type: "Then" })
}
function Feature(name, fn) {
const feature = { name, scenarios: [] }
features.push(feature)
const currentFeature = feature
global.Scenario = (name, body) => {
currentFeature.scenarios.push({ name, body })
}
fn()
}
async function run() {
console.log(color("\n=== Running Gherkin-like Tests ===\n", "magenta"))
const args = process.argv.slice(2)
let filterRegex = null
const runIndex = args.indexOf("--run")
if (runIndex !== -1 && args[runIndex + 1]) {
try {
filterRegex = new RegExp(args[runIndex + 1])
} catch (e) {
console.error(color(`Invalid filter regex: ${e.message}`, "red"))
process.exit(1)
}
}
let passed = 0
let failed = 0
for (const feature of features) {
const matchingScenarios = feature.scenarios.filter(s =>
!filterRegex || filterRegex.test(s.name) || filterRegex.test(feature.name)
)
if (matchingScenarios.length === 0) continue
console.log(color(`Feature: ${feature.name}`, "blue"))
for (const scenario of matchingScenarios) {
console.log(color(`  Scenario: ${scenario.name}`, "cyan"))
let scenarioFailed = false
const lines = scenario.body
.split("\n")
.map((l) => l.trim())
.filter((l) => l.length > 0)
const context = {} // Shared context for steps in a scenario
for (const line of lines) {
let matchFound = false
const cleanLine = line.replace(/^(Given|When|Then|And|But)\s+/i, "")
for (const stepDef of stepDefinitions) {
let match
if (typeof stepDef.pattern === "string") {
if (cleanLine === stepDef.pattern) {
match = []
} else if (cleanLine.startsWith(stepDef.pattern)) {
}
} else if (stepDef.pattern instanceof RegExp) {
match = cleanLine.match(stepDef.pattern)
}
if (match) {
matchFound = true
try {
const args = match.slice(1)
await stepDef.fn(context, ...args)
console.log(color(`    ${color("✔", "green")} ${line}`, "gray"))
} catch (e) {
console.error(
color(`    ${color("✘", "red")} ${line} \n      Error: ${e.message}`, "red")
)
scenarioFailed = true
}
break // Stop looking for definitions for this line
}
}
if (!matchFound) {
console.error(color(`    ? Undefined step: ${line}`, "yellow"))
scenarioFailed = true
}
if (scenarioFailed) break
}
if (scenarioFailed) {
failed++
} else {
passed++
}
}
}
console.log(color("\n=== Summary ===", "magenta"))
console.log(`Total Scenarios: ${passed + failed}`)
console.log(color(`Passed:          ${passed}`, "green"))
console.log(color(`Failed:          ${failed}`, failed > 0 ? "red" : "green"))
if (failed > 0) {
process.exitCode = 1
}
}
export default {
Feature,
Given,
When,
Then,
run,
}
})();
(function(){
var color = window.color;
const tests = []
let currentSuite = ""
async function Group(name, fn) {
const previousSuite = currentSuite
currentSuite = `${previousSuite}[${name}] `
await fn()
currentSuite = previousSuite
}
function Test(name, fn) {
const testName = `${currentSuite}${name}`
tests.push({ name: testName, fn })
}
async function run() {
let passed = 0
let failed = 0
let skipped = 0
const args = process.argv.slice(2)
let filterRegex = null
const runIndex = args.indexOf("--run")
if (runIndex !== -1 && args[runIndex + 1]) {
try {
filterRegex = new RegExp(args[runIndex + 1])
} catch (e) {
console.error(color(`Invalid filter regex: ${e.message}`, "red"))
process.exit(1)
}
}
console.log(color("\n=== Running Go-like Tests ===\n", "cyan"))
for (const test of tests) {
if (filterRegex && !filterRegex.test(test.name)) {
console.log(color(`    [SKIP] ${test.name}: Filtered out`, "yellow"))
skipped++
continue
}
let isFailed = false
let isSkipped = false
const t = {
name: test.name,
Assert: (condition, msg) => {
if (!condition) {
console.error(
color(`    [FAIL] ${test.name}: ${msg || "Assertion failed"}`, "red")
)
isFailed = true
}
},
Equal: (actual, expected, msg) => {
if (actual !== expected) {
console.error(
color(
`    [FAIL] ${test.name}: ${msg || "Equality check failed"}\n      Expected: ${expected}\n      Actual:   ${actual}`,
"red"
)
)
isFailed = true
}
},
Fail: () => {
isFailed = true
},
Skip: (msg) => {
console.log(color(`    [SKIP] ${test.name}: ${msg || ""}`, "yellow"))
isSkipped = true
},
Log: (...args) => {
console.log(`    [LOG]`, ...args)
},
}
try {
await test.fn(t)
} catch (e) {
console.error(color(`    [ERROR] ${test.name}: ${e.message}`, "red"))
isFailed = true
}
if (isSkipped) {
skipped++
} else if (isFailed) {
failed++
console.log(color(`FAIL: ${test.name}`, "red"))
} else {
passed++
console.log(color(`PASS: ${test.name}`, "green"))
}
}
console.log(color("\n=== Summary ===", "cyan"))
console.log(`Total:   ${tests.length}`)
console.log(color(`Passed:  ${passed}`, "green"))
console.log(color(`Failed:  ${failed}`, failed > 0 ? "red" : "green"))
console.log(color(`Skipped: ${skipped}`, skipped > 0 ? "yellow" : "gray"))
if (failed > 0) {
process.exitCode = 1
}
}
window.Test = Test;
window.Group = Group;
window.run = run;
export default {
Test,
Group,
run,
}
})();